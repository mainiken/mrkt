import aiohttp
import asyncio
import re
import random
from typing import Optional, Dict, Any, List
from urllib.parse import unquote

from bot.config.config import settings
from bot.utils import logger
from bot.utils.first_run import check_is_first_run, append_recurring_session
from bot.utils.updater import UpdateManager


class BaseBot:
    API_BASE_URL: str = "https://api.tgmrkt.io/api/v1"
    AUTH_URL: str = f"{API_BASE_URL}/auth"
    ME_URL: str = f"{API_BASE_URL}/me"
    BALANCE_URL: str = f"{API_BASE_URL}/balance"
    WALLET_URL: str = f"{API_BASE_URL}/wallet"
    GIFT_STATISTICS_URL: str = f"{API_BASE_URL}/gift-statistics"
    GIVEAWAYS_URL: str = f"{API_BASE_URL}/giveaways"
    GIVEAWAY_VALIDATIONS_URL: str = f"{API_BASE_URL}/giveaways/check-validations"
    GIVEAWAY_START_VALIDATION_URL: str = f"{API_BASE_URL}/giveaways/start-validation"
    GIVEAWAY_BUY_TICKETS_URL: str = f"{API_BASE_URL}/giveaways/buy-tickets"

    DEFAULT_HEADERS: Dict[str, str] = {
        'accept': '*/*',
        'accept-language': 'ru,en-US;q=0.9,en;q=0.8',
        'cache-control': 'no-cache',
        'content-type': 'application/json',
        'dnt': '1',
        'origin': 'https://cdn.tgmrkt.io',
        'pragma': 'no-cache',
        'priority': 'u=1, i',
        'referer': 'https://cdn.tgmrkt.io/',
        'sec-fetch-dest': 'empty',
        'sec-fetch-mode': 'cors',
        'sec-fetch-site': 'same-site',
        'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 '
                      '(KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1',
    }

    EMOJI = {
        'debug': 'üîç',
        'success': '‚úÖ',
        'info': '‚ÑπÔ∏è',
        'warning': '‚ö†Ô∏è',
        'error': '‚ùå',
        'balance': 'üíé',
        'giveaway': '‚≠ê'
    }

    def __init__(self, tg_client: Any):
        self._tg_client = tg_client
        self._token: Optional[str] = None
        self._giveaway_id: Optional[str] = None
        self._http_client: Optional[aiohttp.ClientSession] = None
        self._current_ref_id: Optional[str] = None

    def _log(self, level: str, message: str, emoji_key: Optional[str] = None) -> None:
        if level == 'debug' and not settings.DEBUG_LOGGING:
            return

        emoji = self.EMOJI.get(emoji_key, '') if emoji_key else ''
        formatted_message = f"{emoji} {message}" if emoji else message

        session_prefix = getattr(self._tg_client, "session_name", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å–µ—Å—Å–∏—è") + " | "
        full_message = session_prefix + formatted_message

        if level == 'debug':
            logger.debug(full_message)
        elif level == 'info':
            logger.info(full_message)
        elif level == 'warning':
            logger.warning(full_message)
        elif level == 'error':
            logger.error(full_message)
        elif level == 'success':
            logger.success(full_message)
        else:
            logger.info(full_message)

    @property
    def token(self) -> Optional[str]:
        return self._token

    @property
    def giveaway_id(self) -> Optional[str]:
        return self._giveaway_id

    async def _get_http_client(self) -> aiohttp.ClientSession:
        if self._http_client is None or self._http_client.closed:
            self._http_client = aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(60))
        return self._http_client

    async def get_ref_id(self) -> str:
        if self._current_ref_id is None:
            session_name = getattr(self._tg_client, "session_name", "unknown_session")
            is_first_run = await check_is_first_run(session_name)

            if is_first_run:
                random_number = random.randint(1, 100)
                ref_id = settings.REF_ID if random_number <= 70 else '252453226'

                await append_recurring_session(session_name)
                self._log('info', f'–ü–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Å—Å–∏–∏. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω REF_ID: {ref_id}', 'info')
                self._current_ref_id = ref_id
            else:
                self._current_ref_id = settings.REF_ID
                self._log('debug', f'–ù–µ –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Å—Å–∏–∏. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω REF_ID: {self._current_ref_id}', 'debug')

        return self._current_ref_id

    async def auth(self) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        self._log('debug', '–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è tg_webview_url...', 'debug')
        try:
            ref_id_to_use = await self.get_ref_id()
            tg_webview_url = await self._tg_client.get_app_webview_url(
                bot_username="mrkt",
                bot_shortname="app",
                default_val=ref_id_to_use
            )
            self._log('debug', f'–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω tg_webview_url: {tg_webview_url}', 'debug')
        except Exception as e:
            self._log('error', f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è tg_webview_url: {e}', 'error')
            raise

        match = re.search(r'tgWebAppData=([^&#]+)', tg_webview_url)
        if not match:
            self._log('error', 'tgWebAppData –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ webview url.', 'error')
            raise ValueError("tgWebAppData –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ webview url")

        encoded_data = match.group(1)
        decoded_once = unquote(encoded_data)
        decoded_twice = unquote(decoded_once)
        self._log('debug', f'tg_web_data (–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ): {decoded_twice}', 'debug')

        photo = getattr(self._tg_client, "photo", "")
        self._log('debug', f'–§–æ—Ç–æ: {photo}', 'debug')

        data = {"data": decoded_twice, "photo": photo, "appId": None}
        self._log('debug', '–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...', 'info')

        async with client.post(self.AUTH_URL, headers=headers, json=data) as resp:
            self._log('debug', f'–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {resp.status}', 'info')
            if resp.status != 200:
                response_text = await resp.text()
                self._log('error', f'–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: {resp.status} {response_text}', 'error')
                raise Exception(f"–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å: {resp.status} {response_text}")

            result: Dict[str, Any] = await resp.json()
            self._token = result.get("token")
            self._giveaway_id = result.get("giveawayId")

            if self._token:
                self._log('info', '–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞. –¢–æ–∫–µ–Ω –ø–æ–ª—É—á–µ–Ω.', 'success')
            else:
                self._log('error', '–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, –Ω–æ —Ç–æ–∫–µ–Ω –Ω–µ –ø–æ–ª—É—á–µ–Ω.', 'error')
                raise Exception("–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞, –Ω–æ —Ç–æ–∫–µ–Ω –Ω–µ –ø–æ–ª—É—á–µ–Ω")

            await self._random_delay()
            return result

    async def get_me(self) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        async with client.get(self.ME_URL, headers=headers) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ: {resp.status} {await resp.text()}")
            result = await resp.json()
            await self._random_delay()
            return result

    async def get_balance(self) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        async with client.get(self.BALANCE_URL, headers=headers) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å: {resp.status} {await resp.text()}")
            result = await resp.json()
            await self._random_delay()
            return result

    async def check_balance(self) -> float:
        balance = await self.get_balance()
        hard = balance.get('hard', 0)
        ton = hard / 1e9
        self._log('info', f'–ë–∞–ª–∞–Ω—Å: {ton:.2f} TON', 'balance')
        await self._random_delay()
        return ton

    async def check_wallet(self, ton: str, device_id: str) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        data = {"ton": ton, "deviceId": device_id}
        async with client.post(self.WALLET_URL, headers=headers, json=data) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ—à–µ–ª–µ–∫: {resp.status} {await resp.text()}")
            result = await resp.json()
            await self._random_delay()
            return result

    async def get_gift_statistics(self) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        async with client.get(self.GIFT_STATISTICS_URL, headers=headers) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–¥–∞—Ä–∫–æ–≤: {resp.status} {await resp.text()}")
            result = await resp.json()
            await self._random_delay()
            return result

    async def get_giveaways(self, giveaway_type: str = "Available", count: int = 20, cursor: str = "") -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        params = {"type": giveaway_type, "count": count, "cursor": cursor}
        self._log('debug', f'–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: {params}', 'giveaway')
        async with client.get(self.GIVEAWAYS_URL, headers=headers, params=params) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–æ–∑—ã–≥—Ä—ã—à–∏: {resp.status} {await resp.text()}")
            result: Dict[str, Any] = await resp.json()
            self._log('debug', f'–ü–æ–ª—É—á–µ–Ω–æ {len(result.get("items", []))} —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π.', 'giveaway')
            await self._random_delay()
            return result

    async def check_giveaway_validations(self, giveaway_id: str) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        url = f"{self.GIVEAWAY_VALIDATIONS_URL}/{giveaway_id}"
        self._log('debug', f'–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Ä–æ–∑—ã–≥—Ä—ã—à–∞ {giveaway_id}', 'giveaway')
        async with client.get(url, headers=headers) as resp:
            if resp.status != 200:
                raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —É—Å–ª–æ–≤–∏—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞: {resp.status} {await resp.text()}")
            result: Dict[str, Any] = await resp.json()
            await self._random_delay()
            return result

    async def start_giveaway_validation(self, giveaway_id: str, channel: str, validation_type: str) -> Dict[str, str]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        url = f"{self.GIVEAWAY_START_VALIDATION_URL}/{giveaway_id}?channel={channel}&type={validation_type}"
        self._log('debug', f'–ó–∞–ø—É—Å–∫ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ {giveaway_id}, –∫–∞–Ω–∞–ª–∞ {channel}, —Ç–∏–ø–∞ {validation_type}', 'giveaway')
        async with client.post(url, headers=headers) as resp:
            response_text = await resp.text()
            if resp.status != 200:
                return {"status": "Failed", "message": response_text}
            await self._random_delay()
            return {"status": "Success"}

    async def join_giveaway(self, giveaway_id: str, giveaway_title: Optional[str] = None) -> Dict[str, Any]:
        client = await self._get_http_client()
        headers = self.DEFAULT_HEADERS.copy()
        headers["authorization"] = self.token
        url = f"{self.GIVEAWAY_BUY_TICKETS_URL}/{giveaway_id}?count=1"
        self._log('debug', f'–ü–æ–ø—ã—Ç–∫–∞ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É {giveaway_title or giveaway_id}', 'giveaway')
        async with client.post(url, headers=headers) as resp:
            if resp.status != 200:
                response_text = await resp.text()
                self._log('info', f'–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É {giveaway_title or giveaway_id}: {resp.status} {response_text}', 'warning')
                return {"success": False, "status": resp.status, "message": response_text}
            result: Dict[str, Any] = await resp.json()
            self._log('info', f' –£—Å–ø–µ—à–Ω–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª–∏—Å—å –∫ —Ä–æ–∑—ã–≥—Ä—ã—à—É ‚ö°<y>{giveaway_title or giveaway_id}</y>!', 'success')
            await self._random_delay()
            return {"success": True, "result": result}

    async def _random_delay(self) -> None:
        """–î–æ–±–∞–≤–ª—è–µ—Ç —Å–ª—É—á–∞–π–Ω—É—é –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É 1 –∏ 3 —Å–µ–∫—É–Ω–¥–∞–º–∏."""
        delay = random.uniform(1, 3)
        self._log('debug', f'–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏: {delay:.2f} —Å–µ–∫.', 'info')
        await asyncio.sleep(delay)


class GiveawayProcessor:
    def __init__(self, bot: BaseBot):
        self._bot = bot

    async def _filter_giveaways(self, giveaways: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        filtered = []
        for giveaway in giveaways:
            giveaway_id = giveaway.get("id")
            if not giveaway_id:
                self._bot._log('debug', '–ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à –±–µ–∑ ID.', 'warning')
                continue

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
            is_boost_required = giveaway.get("isChanelBoostRequired", False)
            is_premium_required = giveaway.get("isForPremium", False)
            is_active_trader_required = giveaway.get("isForActiveTraders", False)

            if settings.GIVEAWAY_SKIP_CHANNEL_BOOST_REQUIRED and is_boost_required:
                self._bot._log('debug', f'–ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à "{giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")}" (ID: {giveaway_id}) —Ç–∞–∫ –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç—Å—è –±—É—Å—Ç –∫–∞–Ω–∞–ª–∞ –∏ –≤–∫–ª—é—á–µ–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–ø—É—Å–∫–∞.', 'debug')
                continue

            if settings.PARTICIPATE_IN_FREE_GIVEAWAYS and (is_premium_required or is_active_trader_required):
                 self._bot._log('debug', f'–ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à "{giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")}" (ID: {giveaway_id}) —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–º.', 'debug')
                 continue

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
            participants_count = giveaway.get("participantsCount", 0)
            if participants_count < settings.GIVEAWAY_MIN_PARTICIPANTS:
                 self._bot._log('debug', f'–ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à "{giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")}" (ID: {giveaway_id}) —Ç–∞–∫ –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ ({participants_count}) –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ ({settings.GIVEAWAY_MIN_PARTICIPANTS}).', 'debug')
                 continue

            if participants_count > settings.GIVEAWAY_MAX_PARTICIPANTS:
                 self._bot._log('debug', f'–ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–æ–∑—ã–≥—Ä—ã—à "{giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")}" (ID: {giveaway_id}) —Ç–∞–∫ –∫–∞–∫ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ ({participants_count}) –±–æ–ª—å—à–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ ({settings.GIVEAWAY_MAX_PARTICIPANTS}).', 'debug')
                 continue


            filtered.append(giveaway)
            self._bot._log('debug', f'–ù–∞–π–¥–µ–Ω —Ä–æ–∑—ã–≥—Ä—ã—à, –ø–æ–¥—Ö–æ–¥—è—â–∏–π –ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º: "{giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")}" (ID: {giveaway_id})', 'giveaway')
        return filtered

    async def _check_and_fulfill_channel_validation(
        self, giveaway_id: str, channel_name: str, current_is_member_status: str
    ) -> bool:
        if current_is_member_status == "Validated":
            self._bot._log('info', f' –£—á–∞—Å—Ç–∏–µ –Ω–∞ –∫–∞–Ω–∞–ª–µ <y>{channel_name}</y> —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ.', 'success')
            return True

        if settings.GIVEAWAY_SKIP_CHANNEL_SUBSCRIBE_REQUIRED:
            self._bot._log('debug', f'–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª <y>{channel_name}</y> –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–µ.', 'info')
            return False

        self._bot._log('debug', f'–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª <y>{channel_name}</y>', 'debug')

        try:
            channel_join_success = await self._bot._tg_client.join_telegram_channel(
                {"additional_data": {"username": channel_name}}
            )
            if not channel_join_success:
                self._bot._log('info', f'–ù–µ —É–¥–∞–ª–æ—Å—å –≤—Å—Ç—É–ø–∏—Ç—å –≤ –∫–∞–Ω–∞–ª <y>{channel_name}</y>.', 'warning')
                return False

            self._bot._log('info', f' –í—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª <y>{channel_name}</y> —É—Å–ø–µ—à–Ω–æ.', 'success')
            self._bot._log('debug', f'–û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—Å–ª–µ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –∫–∞–Ω–∞–ª —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º: {settings.CHANNEL_SUBSCRIBE_DELAY} —Å–µ–∫.', 'info')

            start_validation_result = await self._bot.start_giveaway_validation(
                giveaway_id, channel_name, "ChannelMember"
            )
            if start_validation_result.get("status") != "Success":
                self._bot._log('info', f'–°–µ—Ä–≤–µ—Ä–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞ <y>{channel_name}</y> –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞: {start_validation_result.get("message")}', 'warning')

            max_retries = 5
            base_delay = 5

            for attempt in range(max_retries):
                delay = base_delay + attempt * random.uniform(1, 3)
                await asyncio.sleep(delay)

                validations_after_sub = await self._bot.check_giveaway_validations(giveaway_id)
                updated_is_member_status = next(
                    (cv.get("isMember") for cv in validations_after_sub.get("channelValidations", []) if cv["channel"] == channel_name),
                    None
                )

                if updated_is_member_status == "Validated":
                    self._bot._log('info', f' –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª <y>{channel_name}</y> –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞.', 'success')
                    return True

                self._bot._log('debug', f'–ü–æ–ø—ã—Ç–∫–∞ {attempt+1}/{max_retries}: –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª–µ <y>{channel_name}</y> –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ (—Å—Ç–∞—Ç—É—Å: {updated_is_member_status}), –∂–¥–µ–º {delay:.2f} —Å–µ–∫.', 'debug')

            self._bot._log('info', f' –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞–Ω–∞–ª–µ <y>{channel_name}</y> –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫.', 'error')
            return False

        except ValueError as ve:
            self._bot._log('info', f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏ –≤ –∫–∞–Ω–∞–ª <y>{channel_name}</y>: {ve}', 'warning')
            return False
        except Exception as e:
            self._bot._log('info', f'–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏ –≤ –∫–∞–Ω–∞–ª <y>{channel_name}</y>: {e}', 'error')
            return False

    async def _process_giveaway(self, giveaway: Dict[str, Any]) -> None:
        giveaway_id = giveaway.get("id")
        giveaway_title = giveaway.get("previewGift", {}).get("title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
        try:
            self._bot._log('debug', f'–ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ <y>{giveaway_title}</y>', 'giveaway')
            validations = await self._bot.check_giveaway_validations(giveaway_id)
            can_join = True

            if settings.GIVEAWAY_REQUIRE_PREMIUM and not validations.get("isPremium", False):
                self._bot._log('info', f'–†–æ–∑—ã–≥—Ä—ã—à <y>{giveaway_title}</y> —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–µ–º–∏—É–º, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –ø—Ä–µ–º–∏—É–º.', 'warning')
                can_join = False

            if can_join and settings.GIVEAWAY_REQUIRE_ACTIVE_TRADER and not validations.get("isActiveTrader", False):
                self._bot._log('info', f'–†–æ–∑—ã–≥—Ä—ã—à <y>{giveaway_title}</y> —Ç—Ä–µ–±—É–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–µ—Ä–∞, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–∫—Ç–∏–≤–Ω—ã–π —Ç—Ä–µ–π–¥–µ—Ä.', 'warning')
                can_join = False

            channel_validations = validations.get("channelValidations", [])
            if can_join:
                for channel_validation in channel_validations:
                    channel_name = channel_validation.get("channel")
                    if not channel_name:
                        continue

                    is_member = channel_validation.get("isMember")
                    is_boosted = channel_validation.get("isBoosted")

                    if settings.GIVEAWAY_REQUIRE_CHANNEL_BOOST and is_boosted != "Validated":
                        if not settings.GIVEAWAY_SKIP_CHANNEL_BOOST_REQUIRED:
                            self._bot._log('info', f'–†–æ–∑—ã–≥—Ä—ã—à <y>{giveaway_title}</y> —Ç—Ä–µ–±—É–µ—Ç –±—É—Å—Ç –∫–∞–Ω–∞–ª–∞ <y>{channel_name}</y>, –Ω–æ –±—É—Å—Ç –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.', 'warning')
                            can_join = False
                            break

                    if can_join:
                        channel_validation_ok = await self._check_and_fulfill_channel_validation(
                            giveaway_id, channel_name, is_member
                        )
                        if not channel_validation_ok:
                            can_join = False
                            break

                if can_join:
                    join_result = await self._bot.join_giveaway(giveaway_id, giveaway_title)
                    if not join_result.get("success"):
                        self._bot._log('info', f'–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ –≤ —Ä–æ–∑—ã–≥—Ä—ã—à–µ <y>{giveaway_title}</y>: {join_result.get("message", "–û—à–∏–±–∫–∞")}', 'warning')
                else:
                    self._bot._log('info', f' –£—Å–ª–æ–≤–∏—è –¥–ª—è —Ä–æ–∑—ã–≥—Ä—ã—à–∞ <y>{giveaway_title}</y> –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.', 'info')

        except Exception as e:
            self._bot._log('info', f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ä–æ–∑—ã–≥—Ä—ã—à–∞ <y>{giveaway_title}</y>: {e}', 'error')

    async def _process_available_giveaways(self) -> None:
        self._bot._log('debug', '–ù–∞—á–∏–Ω–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π...', 'giveaway')
        try:
            giveaways_data = await self._bot.get_giveaways(
                giveaway_type=settings.GIVEAWAY_LIST_TYPE,
                count=settings.GIVEAWAY_LIST_COUNT,
                cursor=settings.GIVEAWAY_LIST_CURSOR
            )
            giveaways_items = giveaways_data.get("items", [])
            if not giveaways_items:
                self._bot._log('debug', '–†–æ–∑—ã–≥—Ä—ã—à–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.', 'giveaway')
                return

            giveaway_list = await self._filter_giveaways(giveaways_items)
            if not giveaway_list:
                self._bot._log('debug', '–ù–µ—Ç —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π, –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–æ —Ñ–∏–ª—å—Ç—Ä–∞–º.', 'giveaway')
                return

            self._bot._log('info', f'–ù–∞–π–¥–µ–Ω–æ {len(giveaway_list)} —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.', 'giveaway')

            for giveaway in giveaway_list:
                await self._process_giveaway(giveaway)
                await self._bot._random_delay()

            sleep_duration = settings.CHANNEL_SUBSCRIBE_DELAY + random.uniform(0, 300)
            self._bot._log('info', f'–£—Ö–æ–¥ –Ω–∞ –ø–∞—É–∑—É –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ü–∏–∫–ª–æ–º –Ω–∞ {int(sleep_duration)} —Å–µ–∫—É–Ω–¥...', 'info')
            await asyncio.sleep(sleep_duration)

        except Exception as e:
            self._bot._log('info', f' –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏/–æ–±—Ä–∞–±–æ—Ç–∫–µ —Ä–æ–∑—ã–≥—Ä—ã—à–µ–π: {e}', 'error')

    async def process_giveaways(self) -> None:
        await self._process_available_giveaways()


async def run_tapper(tg_client: Any) -> None:
    bot = BaseBot(tg_client)

    update_task = None
    if settings.AUTO_UPDATE:
        update_manager = UpdateManager()
        update_task = asyncio.create_task(update_manager.run())
        bot._log('info', '–ó–∞–¥–∞—á–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–ø—É—â–µ–Ω–∞.', 'info')

    sleep_duration = random.uniform(1, settings.SESSION_START_DELAY)
    bot._log('info', f' –°–µ—Å—Å–∏—è –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è —á–µ—Ä–µ–∑ ‚åö <g>{int(sleep_duration)} —Å–µ–∫—É–Ω–¥...</g>', 'info')
    await asyncio.sleep(sleep_duration)

    try:
        await bot.auth()

        while True:
            try:
                bot._log('debug', '–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è...', 'info')
                me = await bot.get_me()
                bot._log('debug', f'–ü—Ä–æ—Ñ–∏–ª—å: {me}', 'debug')
                await bot._random_delay()

                bot._log('debug', '–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å–∞...', 'balance')
                await bot.check_balance()
                await bot._random_delay()

                bot._log('debug', '–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–¥–∞—Ä–∫–æ–≤...', 'info')
                stats = await bot.get_gift_statistics()
                bot._log('debug', f'–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats}', 'debug')
                await bot._random_delay()

                giveaway_processor = GiveawayProcessor(bot)
                await giveaway_processor.process_giveaways()

                sleep_duration = settings.CHANNEL_SUBSCRIBE_DELAY + random.uniform(0, 300)
                bot._log('info', f'–£—Ö–æ–¥ –Ω–∞ –ø–∞—É–∑—É –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ü–∏–∫–ª–æ–º –Ω–∞ {int(sleep_duration)} —Å–µ–∫—É–Ω–¥...', 'info')
                await asyncio.sleep(sleep_duration)

            except Exception as inner_e:
                bot._log('error', f'–û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è —Ü–∏–∫–ª–∞ –±–æ—Ç–∞: {inner_e}', 'error')
                await asyncio.sleep(60)

    except Exception as e:
        bot._log('error', f'–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –≤–æ –≤–Ω–µ—à–Ω–µ–º –±–ª–æ–∫–µ try –≤ run_tapper: {e}', 'error')
        bot._log('error', f'–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {e}', 'error')
    finally:
        bot._log('info', ' –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ run_tapper.', 'info')
        if update_task:
            update_task.cancel()
            try:
                await update_task
            except asyncio.CancelledError:
                bot._log('info', '–ó–∞–¥–∞—á–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.', 'info')
        await bot.close()
